---
title: Vue知识点
categories:
 - 前端
tags:
---

# Vue知识点

## Vue组件

### props详解

**父组件向子组件传递数据**

组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。

也就是`props`是子组件访问父组件数据的唯一接口。

详细解释:

* 一个组件可以直接在模板里面渲染data里面的数据(双大括号)

* 子组件不能直接在模板里面渲染父元素的数据

* 如果子组件想要引用父元素的数据,那么就在prop里面声明一个变量(比如a),用父元素的数据.然后在模板里渲染这个变量(前面的a),这时候渲染出来的就是父元素里面的数据.

```html
    <div id="app1">
        <!-- hello引用父元素的hello，它也可以引用message,greet，world等 -->
        <child :hello='hello'></child>
    </div>
 
```

```javascript
   <script>
        var com1 = Vue.component('child',{
            // 声明在prop中的变量可以引用父元素的数据
            props:['hello'],
           // 这里渲染props中声明的那个hello
            template:'<div><p>{{ hello }}</p></div>',
        })
 
        var app1 = new Vue ({
            el: '#app1',
            data: {
                greet: {
                    hello:'hello,',
                    world: 'world',
                },
                message: 'message1',
            }
        })
    </script>
```



### vm.$emit

***作用:触发自定义事件***

子组件可以使用 $emit 触发父组件的自定义事件.

解析:

* 首先看自定义组件son,给其绑定了方法@:clickChange;
* 点击son时会执行函数clickChange,clickChange中有this.$emit('changestar',"加参数");
* 当clickChange执行时,就会触发自定义函数changestar,也就是父组件的mychange函数
* 父组件要监听自定义函数changestar,里面传递父组件的定义了的方法(mychange函数)
* **子组件触发自定义事件,父组件要监听其事件,才会有效果**

```html

 <div id="app">
        <son v-on:changestar="mychange"></son>
        {{mypro}}
 </div>
```



```javascript
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
<script>
    //自定义组件son
    Vue.component("son", {
        template: "<button @click='clickChange'>点击</button>",
        methods: {
            clickChange() {
                this.$emit("changestar", {a:"moon"})
                //触发自定义函数changetext事件,此时的changetext函数就是mychange函数
            }
        }
    });

	//Vue根实例
    let app = new Vue({
        el: "#app",
        data: {
            mypro: "star"
        },
        methods: {
            mychange(data) {
                console.log(data);
                this.mypro = data.a;//拿到子组件传递的数据修改父组件的数据
            }
        }
    })
</script>
```



## Vue实例属性

### $el

Vue实例使用的根DOM元素

### $data

获取数据对象data

### $refs

一个对象,获取注册过ref特性的所有DOM元素和组件实例

### $options

获取自定义属性

```javascript
<div id="itany">
   {{msg}}
   <h2 ref="hello">你好</h2>
   <p ref="world">世界</p>	<hr>
   <h1 ref="title">标题：{{name}}</h1>
</div>
...
var vm=new Vue({
	el:'#itany',
	data:{
	     msg:'welcome to beijing'
	},
	name:'tom',
	show:function(){
	     console.log('show');
	}
});
// vm.属性名 获取data中的属性
   console.log(vm.msg);//welcome to beijing
// vm.$el 获取vue实例关联的元素
   console.log(vm.$el); //DOM对象
   vm.$el.style.color='red';
// vm.$data //获取数据对象data
   console.log(vm.$data);
   console.log(vm.$data.msg);
// vm.$options //获取自定义属性
   console.log(vm.$options.name);
   vm.$options.show();
// vm.$refs 获取所有添加ref属性的元素
   console.log(vm.$refs);
   console.log(vm.$refs.hello); //DOM对象
   vm.$refs.hello.style.color='blue';

```



## Vue实例方法

### vm.$mount()

手动挂载vue实例//vm.$mount('#itany');

```javascript
var vm=new Vue({
   data:{
	msg:'欢迎来到南京网博',
	name:'tom'
    }
}).$mount('#itany');
```



### vm.$destory()

销毁实例

### vm.$nextTick(callback)

在DOM更新完成后再执行回调函数,一般在修改数据之后使用该方法,以便获取更新后的DOM

```javascript
<div id="itany">
   <h1 ref="title">标题：{{name}}</h1>
</div>
...
var vm = new Vue({
  el: '#itany',
  data: {
    msg: 'welcome to beijing',
    name: 'tom'
  }
});
vm.name='汤姆';//虽然页面展示已经更改过来了，但DOM还没更新完
//Vue实现响应式并不是数据发生改变之后DOM立即变化，需要按一定的策略进行DOM更新，需要时间！！
console.log(vm.$refs.title.textContent);//标题：tom 取到的值还是旧的
vm.$nextTick(function () {
//DOM更新完成，更新完成后再执行此代码
  console.log(vm.$refs.title.textContent);标题：汤姆
});

```



### vm.$set(target,key)

与Vue.set用法相同

参数：

{Object | Array} target

{string | number} key

{any} value

用法：**向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为Vue 无法探测普通的新增属性**,比如下面例子中的this.user.age=25，页面并不能展示{{this.age}}的数据

```javascript
<div id="itany">
  <button @click="doAdd">添加属性</button>
<hr>
  <h2>{{user.name}}</h2>
  <h2>{{user.age}}</h2>
</div>
...
var vm = new Vue({
  el: '#itany',
  data: {
    user: {
      id: 1001,
      name: 'tom'
    }
  },
  methods: {
    doAdd() {
      // this.user.age=25; //通过普通方式为对象添加属性时vue无法实时监视到
      // this.$set(this.user,'age',18); //通过vue实例的$set方法为对象添加属性，可以实时监视
      // Vue.set(this.user,'age',18);
      if (this.user.age) {
        this.user.age++;
      } else {
        Vue.set(this.user, 'age', 1);
      }
    }
  }
})

```



### vm.$get(target,key)

与Vue.get用法相同

### vm.$delete(target.key)

与Vue.delete用法相同

参数：

{Object | Array} target

{string | number} key

用途：删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。

```javascript
doDelete() {
  if (this.user.age) {
    // delete this.user.age; 此方法无效
    Vue.delete(this.user, 'age');
  }
}
```



### vm.$watch(data,callback[,options])

数据监视

```javascript

//方式1：使用vue实例提供的$watch()方法
vm.$watch('name', function (newValue, oldValue) {
  console.log('name被修改啦，原值：' + oldValue + '，新值：' + newValue);
});
当对象中的属性发生变化时,也可以采用这种办法
vm.$watch（"user",function(newValue,oldValue){
  console.log('user被修改啦，原值：'+oldValue.name+'，新值：'+newValue.name);
},true)

```







